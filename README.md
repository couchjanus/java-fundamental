# ООП - Объектно-ориентированное программирование 

## Основные принципы ООП в Java
- Инкапсуляция
- Наследование
- Полиморфизм

Инкапсуляция — принцип, согласно которому атрибуты объекта заключаются в этот объект. Это задает для атрибутов контекст. Это также позволяет программисту ограничить доступ к атрибутам, чтобы они изменялись и использовались только через методы, которые программист собирается применять:

Наследование – принцип  ООП в Jаva, согласно которому объект может наследовать атрибуты другого объекта. Это позволяет программисту создавать похожие объекты без повторного переопределения атрибутов:

Полиморфизм означает иметь много форм - используется один и тот же метод, только по-разному. 

## Классы в Java
Каждый файл в языке Java является классом, поэтому, чтобы создать класс необходимо создать новый файл в проекте. Название файла это и есть название класса, поэтому давайте осмысленные имена.

В любом классе можно создавать поля (переменные), методы (функции), а также конструкторы. 

Создав новый класс мы можем создавать на основе него новые объекты. Объекты будут иметь доступ ко всем характеристикам класса, которые отмечены модификатором public.

## Существует три модификатора доступа:
- public - данные будут видны повсюду, как в классе, так и вне его;
- protected - данные будут видны только в классе, где они были созданы, а также в классах наследниках;
- private - данные будут видны только в классе, где они были созданы.

У каждого объекта есть свойства. Например, свойства машины: модель, цвет, размер и т.д.

У каждого объекта есть методы (то есть действия, которые может делать объект). Например, методы машины: затормозить, нажать на газ и т.д.

Класс - это шаблон для объекта. Понятие класса, как и понятие объекта, являются основой ООП.

## Создание класса и объекта

сначала указывается название класса, например Cat:
```java

class Cat{
 
 String name;
 String color;
 
}

```

На основе такого класса мы можем создать множество объектов. Каждый объект будет представлять из себя конкретную кошку. Для каждого объекта мы можем указать уникальные данные: имя, цвет и т.д.

## Чтобы создать объект:

Словом new Вы даете команду создать новый экземпляр класса. В скобках может ничего не стоять, но для создания некоторых объектов (экземпляров класса) понадобятся первоначальные параметры, которые надо будет указывать в скобках.
```java

Cat cat; // объявление переменной
cat = new Cat(); // выделение памяти под объект Cat

```
Для доступа к объекту необходимо ставить точку и указывать имя переменной или функции
```java

cat.name = "Cooma";

```
## Метод в Java
Метод в Java — это комплекс выражений, совокупность которых позволяет выполнить определенную операцию. 

### Создание метода
```java

public static int methodName(int a, int b) {
   // тело
}

```
Где:

- public static — модификатор;
- int — возвращаемый тип;
- methodName — имя метода;
- a, b — формальные параметры;
- int a, int b — перечень параметров.

```java

// Определение метода представлено заголовком и телом метода.

modifier returnType nameOfMethod (Parameter List) {
   // тело метода
}

```
Где:

- modifier – определяет тип доступа для метода и возможность его использования.
- returnType – метод может возвратить значение.
- nameOfMethod – указывает имя метода. Сигнатура метода включает имя метода и перечень параметров.
- Parameter List – перечень параметров представлен типом, порядком и количеством параметров метода. Данная опция задается произвольно, в методе может присутствовать нулевой параметр.
- method body – тело метода определяет метод работы с командами.

```java

/* фрагмент кода возвращает минимальное между двумя числами */

public static int minFunction(int n1, int n2) {
   int min;
   if (n1 > n2)
      min = n2;
   else
      min = n1;

   return min; 
}

```
Название метода должно быть уникальным. Если название состоит из нескольких слов, напишите его, используя CamelCase.

### Вызов метода
Перед использованием метода его необходимо вызвать. Существует два способа для вызова метода в Java, т.е. метод производит возврат значения либо не производит (отсутствует возвращающее значение).

### Алгоритм вызова метода. 
Когда программа производит в Java вызов метода, программное управление передается вызванному методу. Данный вызванный метод возвращает управление вызывающему клиенту в двух случаях, если:
- выполняется оператор возврата;
- достигнута закрывающая фигурная скобка окончания метода.

### Метод возврата значения:
```java

int result = sum(6, 9);

public class ExampleMinNumber {
   
   public static void main(String[] args) {
      int a = 11;
      int b = 6;
      int c = minFunction(a, b);
      System.out.println("Минимальное значение = " + c);
   }

   /* Возвращает минимум из двух чисел */
   public static int minFunction(int n1, int n2) {
      int min;
      if (n1 > n2)
         min = n2;
      else
         min = n1;

      return min; 
   }
}


```
## Ключевое слово void
Ключевое слово void в Java позволяет создать методы, не возвращающие значения. 
```java

public class ExampleVoid {

   public static void main(String[] args) {
      methodRankPoints(255.7);
   }

   public static void methodRankPoints(double points) {
      if (points >= 202.5) {
         System.out.println("Ранг A1");
      }else if (points >= 122.4) {
         System.out.println("Ранг A2");
      }else {
         System.out.println("Ранг A3");
      }
   }
}

```
## Передача параметров по значению в Java
При выполнении вызывающего процесса производится передача аргументов. Процедура должна осуществляться согласно порядку, предусмотренному соответствующими параметрами в спецификации метода. Передача параметров может производиться по значению либо по ссылке.

В Java передача параметров по значению обозначает вызов метода с параметром. За счет этого производится передача значения аргумента параметру.

### Пример передачи параметра по значению. 
```java

public class swappingExample {

   public static void main(String[] args) {
      int a = 30;
      int b = 45;
      System.out.println("Перед тем как передать, значения аргументов a = " + a + " и b = " + b);

      // Вызов метода передачи
      swapFunction(a, b);
      System.out.println("\nСейчас, до и после передачи значения аргументов ");
      System.out.println("остались неизменными, a = " + a + " и b = " + b);
   }

   public static void swapFunction(int a, int b) {
      System.out.println("До замены: a = " + a + " b = " + b);
      
      // Передача параметров
      int c = a;
      a = b;
      b = c;
      System.out.println("После замены: a = " + a + " b = " + b);
   }
}

```
Значения аргументов остаются неизменными даже после вызова метода.

## Метод main
Метод main - не обязательно должен присутствовать в каждом классе. Он необходим для запуска программы - поэтому понадобиться только один раз. Все остальные классы - это набор вспомогательных методов-инструментов


## Геттеры и Сеттеры

Это общепринятый способ вводить данные (set) или получать данные (get).
getter - get - получать, 
setter - set - устанавливать

Например, у меня есть класс Cat - кошка. Я задаю (используя setter) имя, пол, цвет глаз и окрас кошки (или кота). Если нужно узнать, какое у кошки имя - получаю с помощь getter - в данном случае getCatName :

С помощью геттеров и сеттеров Вы защищаете содержимое программы (инкапсуляция) - когда ей пользуется кто-то другой.
```java

class Cat{
 
 String name;
 String color;
 
}

```
Для создания геттера и сеттера понадобится две составляющие:
1. Задать полям, которые мы хотим защитить, свойство private.
```java

class Cat{
 
 private String name;
 private String color;
 
}

```
2. Написать метод геттер / сеттер для каждого поля.
```java

// Для поля name:

class Cat{
 
 private String name;
 private String color;
 
 public String getName(){
      return name;
 } 
 
 public void setName(String a){
      name=a;
 }
}

```
Метод getName (имя метода-геттера состоит из слова get + название переменной) - это метод, который возвращает переменную типа String, и при этом не требует никаких данных.

Метод setName (имя метода-сеттера тоже состоит из слова set + название переменной) ничего не возвращает (void) но при этом требует String - новое значение для переменной name.

### Геттер и сеттер для переменной color:
```java

class Cat{
 
 private String name;
 private String color;
 
 public String getName(){
      return name;
 } 
 
 public void setName(String a){
      name = a;
 }
 
 public String getColor(){
      return color;
 } 
 
 public void setColor(String color){
      this.color = color;
 }
 
}

```
## Ключевое слово this
Ключевое слово this — используется для ссылки на текущий класс с учетом метода или конструктора экземпляра. Используя this в Java, Вы можете ссылаться на экземпляры класса, такие как конструкторы, переменные и методы.

Ключевое слово this используется только в составе методов либо конструкторов экземпляра.

Ключевое слово this в Java используется для:
- дифференцирования между переменными экземпляра и локальными переменными в случае, если у них одинаковые имена, в составе конструктора или метода.
```java

class Student {
   int age;   
   Student(int age) {
      this.age = age;   
   }
}

```
- вызова конструктора одного типа (параметризованного конструктора либо конструктора по умолчанию) из другого в составе класса. Данный процесс также носит название явного вызова конструктора.
```java

class Student {
   int age
   Student() {
      this(20);
   }
   
   Student(int age) {
      this.age = age;   
   }
}


``` 
Пример, в котором ключевое слово this используется для доступа к экземплярам класса. 
```java

public class This_Example {
   // Инициализация переменной num
   int num = 11;
    
   This_Example() {
      System.out.println("Это пример программы с ключевым словом this");    
   }

   This_Example(int num) {
      // Вызов конструктора по умолчанию
      this();
      
      // Присвоение локальной переменной num переменной экземпляра num
      this.num = num;      
   }
   
   public void greet() {
      System.out.println("Привет! Добро пожаловать!");
   }
      
   public void print() {
      // Локальная переменная num
      int num = 20;
      
      // Вызов метода класса greet
      this.greet(); 

      // Вывод локальной переменной.
      System.out.println("Значение локальной переменной num: " + num);
      
      // Вывод переменной экземпляра.
      System.out.println("Значение переменной экземпляра num: " + this.num);          
   }
   
   public static void main(String[] args) {
      // Инициализация класса
      This_Example obj1 = new This_Example();
      
      // Вызов метода print
      obj1.print();
      
      // Передача нового значения переменной num через параметризованный конструктор
      This_Example obj2 = new This_Example(30);
      
      // Вызов снова метода print
      obj2.print(); 
   }
}


```
## Обращайте внимание на следующее:
1. Имена полей (переменных, содержащихся в классе) всегда пишется с маленькой буквы (например, int number, String name, и т.д.).
2. Имена геттеров и сеттеров - в формате "get" + имя переменной с большой буквы (например, getColor, getName).
3. Метод геттер не имеет параметров (т.е. в скобках ничего не пишется) и возвращает значение одной переменной (одного поля).
4. Метод сеттер всегда имеет модификатор void и только один параметр, для изменения значения одного поля.


## Параметр переменной длины typeName... parameterName
При объявлении метода Вы указываете тип, за которым следует многоточие (...). В методе может быть указан только один параметр переменной длины, и этот параметр должен быть последним параметром. Любые регулярные параметры должны предшествовать ему.

```java

public class VarargsDemo {

   public static void main(String args[]) {
      // Вызов метода с переменной args  
      printMax(27, 11, 11, 5, 77.1);
      printMax(new double[]{10, 11, 12, 77, 71});
   }

   public static void printMax(double... numbers) {
      if (numbers.length == 0) {
         System.out.println("Ни один аргумент не передается");
         return;
      }

      double result = numbers[0];

      for (int i = 1; i <  numbers.length; i++)
      if (numbers[i] >  result)
      result = numbers[i];
      System.out.println("Максимальное значение " + result);
   }
}

```

## Конструкторы в Java

В Java конструктор инициализирует объект при его создании. Его имя аналогично имени класса, а синтаксис сходен с синтаксисом метода. Однако, в отличие от последнего, в конструкторе отсутствует возвращаемое значение.

Как правило, конструктор в Java может использоваться для присвоения исходного значения переменных экземпляра, определяемых классом, либо для выполнения каких-либо иных процедур запуска, необходимых для создания полностью сформированного объекта.

Конструкторы присутствуют во всех классах, независимо от их указания, в виду того, что Java автоматически предоставляет конструктор по умолчанию, который инициализирует все переменные членов класса до нуля. После того как вы определите собственный конструктор, конструктор по умолчанию больше не будет задействован.

### Использование конструктора класса без параметров.
```java

// Простой конструктор.
class MyClass {
   int x;

   // Далее следует конструктор
   MyClass() {
      x = 10;
   }
}

```
Для инициализации объектов вам необходимо выполнить вызов конструктора.
```java

public class ConsDemo {

   public static void main(String args[]) {
      MyClass t1 = new MyClass();
      MyClass t2 = new MyClass();
      System.out.println(t1.x + " " + t2.x);
   }
}

```
## Как работает программа.

1. Вы создаете основное тело программы, прописывая метод main:
```java

public class Test {
    public static void main(String[] args){
 
    }
}


```
2. Класс Cat:
```java

class Cat{
 
 private String name;
 private String color;
 
 public String getName(){
      return name;
 } 
 
 public void setName(String a){
      name = a;
 }
 
 public String getColor(){
      return color;
 } 
 
 public void setColor(String color){
      this.color = color;
 }
 
}

```
3. Объект класса Cat
Создать объект класса Cat:
```java

public class Test {
    public static void main(String[] args){
         Cat cat1= new Cat();
    }
}

```
Когда программа приступает к созданию объекта cat1, она ищет конструкторы, которые укажут, как именно создавать объект.

## Явные и неявные конструкторы
Существуют два вида конструкторов - явные и неявные. Даже если ничего не прописать в коде класса, Вы все равно сможете сконструировать объект этого класса. 

Явно прописывая конструктор, Вы получаете возможность регулировать, какие параметры и в каком количестве нужно задать для создания объекта определенного класса.

```java

public class Test {
    public static void main(String[] args){
            Cat cat1= new Cat();
            
            cat1.setName("Murka");
            cat1.setColor("grey");
    }
}

```
Конструктор уменьшает количество строк в коде:
```java

public class Test {
    public static void main(String[] args){
            Cat cat1= new Cat("Murka", "grey");
    }
}

```

## Как создается конструктор

Конструктор - это самый обычный метод, который имеет такое же название, как и класс.
```java

class Cat{
 
 private String name;
 private String color;
 
 public Cat(String x){
      name = x;
 } 
 
}

```
Теперь, невозможно будет создать объект класса Cat без того, чтобы указать его имя. 

Если мы хотим больше параметров, просто указываем больше элементов в скобках:
```java

class Dog{
 
 private String name;
 private String poroda;
 private int age;
 
 public Dog(String x, String y, int z){
      name = x;
      poroda = y;
      age = z;
 } 
 
}

```
Соответственно, внутри метода мы присваиваем введенные значения параметрам нашего класса.

## Параметризованный конструктор
Чаще всего вам может понадобиться конструктор, который принимает один и более параметров. Добавление параметров к конструктору аналогично их добавлению в метод, следует только внести их в круглые скобки после имени конструктора.

### Конструктор с параметром.
```java

// Простой конструктор.
class MyClass {
   int x;
   
   // Ниже конструктор
   MyClass(int i) {
      x = i;
   }
}

```
С целью инициализации объектов вам понадобится вызвать конструктор.
```java

public class ConsDemo {

   public static void main(String args[]) {
      MyClass t1 = new MyClass( 10 );
      MyClass t2 = new MyClass( 20 );
      System.out.println(t1.x + " " + t2.x);
   }
}

```
## Инкапсуляция в Java
Инкапсуляция — принцип, согласно которому атрибуты объекта заключаются в этот объект. Это задает для атрибутов контекст. Это также позволяет программисту ограничить доступ к атрибутам, чтобы они изменялись и использовались только через методы, которые программист собирается применять:
```java

// Эта переменная не инкапсулирована.
// Поэтому в ней отсутствует какой-то контекст.

String name;

// БАЗОВАЯ ИНКАПСУЛЯЦИЯ

// Эти переменные и методы инкапсулированы в классе Dog. Они являются его членами.

class Dog {
    String name;
    int age;
    void bark() {
        System.out.println("Bark!");
    }
    void rename(String newName) {
        name = newName;
    }
}

// МОДИФИКАТОРЫ ДОСТУПА
// Чтобы определить доступ, используются модификаторы доступа:
// - default: Если модификаторы доступа отсутствуют, атрибут доступен только для классов внутри одного пакета.
// - public: атрибут доступен из любого другого класса.
// - protected: То же самое, что и default, плюс он доступен для подклассов.
// - private: доступен только внутри объявленного класса.

class Dog {
    private String name;
    private int age;
    void bark() {
        System.out.println("Bark!");
    }
    void rename(String newName) {
        name = newName;
    }
    public String getName() {
        return name;
    }
    public void setAge(int newAge) {
        if(newAge > 0)
            age = newAge;
    }
    public int getAge() {
        return age;
    }
}

```

## Наследование
Наследование – принцип  ООП в Jаva, согласно которому объект может наследовать атрибуты другого объекта. Это позволяет программисту создавать похожие объекты без повторного переопределения атрибутов:
```java

// Если мы хотим определить собак, кошек и птиц, и мы знаем, что у всех этих животных есть имена и возраст, мы должны создать суперкласс.

// СУПЕРКЛАСС
class Animal {
    private String name;
    private int age;

    public void identify() {
        System.out.println("I am an animal!");
    }

    public void rename(String newName) {
        name = newName;
    }

    public String getName() {
        return name;
    }

    public void setAge(int newAge) {
        if(newAge > 0)
            age = newAge;
    }

    public int getAge() {
        return age;
    }
}

// ПОДКЛАССЫ

class Dog extends Animal {
    public void bark() {
        System.out.println("Bark!");
    }
}

class Cat extends Animal {
    public void meow() {
        System.out.println("Meow!");
    }
}

class Bird extends Animal {
    public void chirp() {
        System.out.println("Chirp!");
    }
}

```
В ООП это означает, что каждая собака, кошка и птица (подклассы) будут иметь атрибуты имени и возраста. А также метод Identify, потому что они являются животными (принадлежат суперклассу Animal).

## Полиморфизм

Полиморфизм означает иметь много форм. Есть два способа реализации полиморфизма:

Перегрузка: имя метода остается неизменным, но параметры, возвращаемый тип и количество параметров могут изменяться:
```java

// ПЕРЕГРУЗКА

// Класс Animal реализует 3 метода конструктора, которые перегружаются.
// Это означает, что мы можем создать новое животное тремя разными способами.

class Animal {
    private String name;
    private int age;
    Animal() {
        name = "Fred";
        age = 12;
    }
    Animal(String nm) {
        name = nm;
        age = 5;
    }
    Animal(String nm, int newAge) {
        name = nm;
        age = newAge;
    }
    
}

```
Перегрузка в основах ООП – это когда метод подкласса имеет то же имя, параметры и возвращаемый тип, что и метод в суперклассе, но реализуется по-другому:
```java

// СУПЕРКЛАСС

class Animal {
    
    public void identify() {
        System.out.println("I am an animal!");
    }

}

// ПОДКЛАСС
class Dog extends Animal {
    public void bark() {
        System.out.println("Bark!");
    }

    public void identify() {
        System.out.println("I am a dog!");
    }
}

class Cat extends Animal {
    public void meow() {
        System.out.println("Meow!");
    }

    public void identify() {
        System.out.println("I am a cat!");
    }
}

class Bird extends Animal {
    public void chirp() {
        System.out.println("Chirp!");
    }

    public void identify() {
        System.out.println("I am a bird!");
    }
}

```

## Несколько правил переопределения метода в основах ООП Java:

- Методы подкласса должны иметь одинаковый возвращаемый тип и аргументы;
- Уровень доступа метода подкласса не может быть более низким, чем у метода суперкласса;
- Метод, объявленный завершенным или статическим, нельзя переопределить;
- Если метод не может быть унаследован, его нельзя переопределить.

## Задание

1. Создать супер-класс Дорожные_Средства_Передвижения
В классе реализовать общие свойства и методы 
2. Создать классы наследники. 
- Автомобили
- Двухколесные_Средства 
В классах реализовать свойства и методы

3. Создать классы наследники для Автомобиля
- Грузовые_Автомобили 
- Легковые_Автомобили 
В классах реализовать частные свойства и методы

4. Создать классы наследники для Двухколесные_Средства 
- Велосипеды
- Мотоцыклы
В классах реализовать частные свойства и методы

