# Основные операции с переменными в Java

## В Java все операторы можно разбить на 3 группы:

- арифметические
- логические
- побитовые

## Арифметические операторы

```java
class Test {

    public static void main(String[] args) {
        int k = 70;
        int p = 10;
        int f = 5;
        int m = k+p; 
        System.out.println(m); 
        m = m-30;
        System.out.println(m);
        int s = m*f;
        System.out.println (s);
        s =s/f;
        System.out.println(s);
    }
}
```
## Сокращённые арифметические операторы
есть 2 формы записи основных арифметических операций. Например:
```java


m += 7;  // это всё равно, что m = m+7;

m -= 7 ; // это всё равно, что m = m-7;

m*= 7; // это всё равно, что m = m*7;

m/= 7; // это всё равно, что m = m/7;

class Test {

    public static void main(String[] args) {
        int m = 2;
        m = m + 7;
        System.out.print (m);
    }
}

class Test {

    public static void main(String[] args) {
        int m = 2;
        m+= 7;
        System.out.print (m);
    }
}
```

## Инкремент и декремент

Инкремент - отвечает за увеличение переменной на единицу. Обозначается как ++. Например, если у нас есть переменная i и мы к ней применим инкремент, тогда это будет записано как i++. А это значит, что значение переменной i должно быть увеличено на 1.
Декремент - отвечает за уменьшение переменной на единицу. Обозначается как --. Например, если у нас есть переменная n и мы к ней применим декремент, тогда это будет записано как n --. А это значит, что значение переменной n должно быть уменьшено на 1.

```java
class Test {

    public static void main(String[] args) {
        int n = 2;
        n++;
        System.out.print (n);
    }
}

class Test {

    public static void main(String[] args) {
        int n = 2;
        n--;
        System.out.print (n);
    }
}
```

## Две формы инкремента и декремента
существует 2 формы инкремента:
- постфиксная (n++) 
- префиксная (++n)

существует формы декремента:
- постфиксная (n--)
- префиксная (--n)

В постфиксной форме:
- сначала используется старое значение в вычислениях
- далее в последующих вычислениях используется уже новое значение

В префиксной форме:
- сразу используется новое значение в вычислениях
```java
class Test {

    public static void main(String[] args) {
        int n = 2;
        int k = 2;
        int a = 2 * n++; //теперь значение a равно 4, а n равно 3
        int b = 2 * ++k; //теперь значение b равно 6, а k равно 3
        System.out.println(a);
        System.out.println(n);
        System.out.println(b);
        System.out.println(k);
    }
}
```
инкремент и декремент применяют только к переменной, к числам нельзя применять. Поэтому, например, выражение 8++ или ++8 считаются недопустимыми.

Пример на постфиксную и префиксную формы декремента
```java
class Test {

    public static void main(String[] args) {
        int n = 2;
        int k = 2;
        int a = 2 * n--; //теперь значение a равно 4, а n равно 1
        int b = 2 * --k; //теперь значение b равно 2, а k равно 1
        System.out.println(a);
        System.out.println(n);
        System.out.println(b);
        System.out.println(k);
    }
}
```
## Приоритет операций
Приоритет операций следует учитывать при выполнении набора арифметических выражений:
```java
int a = 8;
int b = 7;
int c = a + 5 * ++b;      
System.out.println(c);  // 48
```
Вначале будет выполняться операция инкремента ++b, которая имеет больший приоритет - она увеличит значение переменной b и возвратит его в качестве результата. Затем выполняется умножение 5 * ++b, и только в последнюю очередь выполняется сложение a + 5 * ++b

Скобки позволяют переопределить порядок вычислений:
```java


int a = 8;
int b = 7;
int c = (a + 5) * ++b;    
System.out.println(c);  // 104
```
Несмотря на то, что операция сложения имеет меньший приоритет, но вначале будет выполняться именно сложение, а не умножение, так как операция сложения заключена в скобки.

## Ассоциативность операций
Кроме приоритета операции отличаются таким понятием как ассоциативность. Когда операции имеют один и тот же приоритет, порядок вычисления определяется ассоциативностью операторов. В зависимости от ассоциативности есть два типа операторов:
- Левоассоциативные операторы, которые выполняются слева направо
- Правоассоциативные операторы, которые выполняются справа налево
Так, некоторые операции, например, операции умножения и деления, имеют один и тот же приоритет. Какой же тогда будет результат в выражении: int x = 10 / 5 * 2;
Стоит нам трактовать это выражение как (10 / 5) * 2 или как 10 / (5 * 2)? Ведь в зависимости от трактовки мы получим разные результаты.

Все арифметические операторы (кроме префиксного инкремента и декремента) являются левоассоциативными, то есть выполняются слева направо. Поэтому выражение 10 / 5 * 2 необходимо трактовать как (10 / 5) * 2, то есть результатом будет 4.

## Операции с числами с плавающей точкой
Следует отметить, что числа с плавающей точкой не подходят для финансовых и других вычислений, где ошибки при округлении могут быть критичными. Например:
```java
double d = 2.0 - 1.1;
System.out.println(d);
```
В данном случае переменная d будет равна не 0.9, как можно было бы изначально предположить, а 0.8999999999999999. Подобные ошибки точности возникают из-за того, что на низком уровне для представления чисел с плавающей точкой применяется двоичная система, однако для числа 0.1 не существует двоичного представления, также как и для других дробных значений. Поэтому в таких случаях обычно применяется класс BigDecimal, который позволяет обойти подобные ситуации.
## Символы
В качестве значения переменная символьного типа получает одиночный символ, заключенный в одинарные кавычки: char ch='e';. Кроме того, переменной символьного типа также можно присвоить целочисленное значение от 0 до 65535. В этом случае переменная опять же будет хранить символ, а целочисленное значение будет указывать на номер символа в таблице символов Unicode (UTF-16). Например:
```java
char ch=102; // символ 'f'
System.out.println(ch);
```
Еще одной формой задания символьных переменных является шестнадцатеричная форма: переменная получает значение в шестнадцатеричной форме, которое следует после символов "\u". Например, char ch='\u0066'; опять же будет хранить символ 'f'.

Символьные переменные не стоит путать со строковыми, 'a' не идентично "a". 
## Строковые переменные
Строковые переменные представляют объект String, который в отличие от char или int не является примитивным типом в Java:
```java
String hello = "Hello...";
System.out.println(hello);
```
String — не примитив. Это реальный тип. Вот несколько способов использования строки:

```java
// Создание строки с помощью конструктора
String s1 = new String("Who let the dogs out?");

// С помощью двойных кавычек (» «).
String s2 = "Who who who who!";

```
Кроме собствено символов, которые представляют буквы, цифры, знаки препинания, прочие символы, есть специальные наборы символов, которые называют управляющими последовательностями. Например, самая популярная последовательность - "\n". Она выполняет перенос на следующую строку. Например:
```java
String text = "Hello \nworld";
System.out.println(text);
```
В данном случае последовательность \n будет сигналом, что необходимо сделать перевод на следующую строку.

Начиная с версии 15 Java поддерживает тестовые блоки (text blocks) - многострочный текст, облеченный в тройные кавычки. Рассмотрим, в чем их практическая польза. Например, выведем большой многострочный текст:
```java
String text = "Вот мысль, которой весь я предан,\n"+
                "Итог всего, что ум скопил.\n"+
                "Лишь тот, кем бой за жизнь изведан,\n"+
                "Жизнь и свободу заслужил.";
System.out.println(text);
```
С помощью операции + мы можем присоединить к одному тексту другой, причем продолжение текста может располагаться на следующей строке. Чтобы при выводе текста происходил перенос на следующую строку, применяется последовательность \n.

Текстовые блоки, которые появились в JDK15, позволяют упростить написание многострочного текста:
```java

    String text = """
                    Вот мысль, которой весь я предан,
                    Итог всего, что ум скопил.
                    Лишь тот, кем бой за жизнь изведан,
                    Жизнь и свободу заслужил.
                    """;
    System.out.println(text);

```
Весь текстовый блок оборачивается в тройные кавычки, при этом не надо использовать соединение строк или последовательность \n для их переноса. Результат выполнения программы будет тем же, что и в примере выше.
## Конкатенация строк в Java
Конкатенация - это синоним слова "объединение". Истоки слова "конкатенация" от латыни: "сon-" означает "вместе", "catena" в переводе с латыни это "цепь".

Конкатенация строк в Java означает, в целом, слияние, "склеивание" двух строк в одну. 

```java
public class Test {

    public static void main(String[] args) {
        // В Java присутсвует конкатенация строк при помощи оператора +.
        String morning1 ="доброе";
        String morning2 ="не доброе, потому что сегодня понедельник";

        System.out.println("Сегодня утро " + morning1);
        System.out.println("Сегодня утро " + morning2);

        String s3 = s1 + s2;

        // В Java нет перегрузки операторов! Оператор + определен только для строк, вы никогда не увидите его с другими объектами, только с примитивами.
        int num = 5;
        String s = "I have " + num + " cookies";
        // Заметьте, что кавычки с примитивами не используются.
    }
}
```
конкатенацию строк можно осуществлять не только с помощью оператора +, есть еще несколько способов. Например, часто используемый метод для слияния строк в Java так и называется .concat() – от concatenation, естественно. 

## Вывод на консоль
Для создания потока вывода в класс System определен объект out. В этом объекте определен метод println, который позволяет вывести на консоль некоторое значение с последующим переводом курсора консоли на следующую строку. Например:
```java
public class Program {
   
    public static void main(String[] args) {
           
        System.out.println("Hello world!");
        System.out.println("Bye world...");
    }
}
```
В метод println передается любое значение, как правило, строка, которое надо вывести на консоль.
При необходимости можно и не переводить курсор на следующую строку. В этом случае можно использовать метод System.out.print(), который аналогичен println за тем исключением, что не осуществляет перевода на следующую строку.
```java
public class Program {
   
    public static void main(String[] args) {
           
        System.out.print("Hello world!");
        System.out.print("Bye world...");
    }
}
```
Но с помощью метода System.out.print также можно осуществить перевод каретки на следующую строку. Для этого надо использовать escape-последовательность \n:
```java
System.out.print("Hello world \n");
```
Нередко необходимо подставлять в строку какие-нибудь данные. Например, у нас есть два числа, и мы хотим вывести их значения на экран. В этом случае мы можем, например, написать так:
```java
public class Program {
   
    public static void main(String[] args) {
           
        int x=5;
        int y=6;
        System.out.println("x=" + x + "; y=" + y);
    }
}
```
Но в Java есть также функция для форматированного вывода, унаследованная от языка С: System.out.printf(). С ее помощью мы можем переписать предыдущий пример следующим образом:
```java
int x=5;
int y=6;
System.out.printf("x=%d; y=%d \n", x, y);
```
В данном случае символы %d обозначают спецификатор, вместо которого подставляет один из аргументов. Спецификаторов и соответствующих им аргументов может быть множество. В данном случае у нас только два аргумента, поэтому вместо первого %d подставляет значение переменной x, а вместо второго - значение переменной y. Сама буква d означает, что данный спецификатор будет использоваться для вывода целочисленных значений.

Кроме спецификатора %d мы можем использовать еще ряд спецификаторов для других типов данных:
```java

%x: для вывода шестнадцатеричных чисел

%f: для вывода чисел с плавающей точкой

%e: для вывода чисел в экспоненциальной форме, например, 1.3e+01

%c: для вывода одиночного символа

%s: для вывода строковых значений

Например:

public class Program {
   
    public static void main(String[] args) {
           
        String name = "Tom";
        int age = 30;
        float height = 1.7f;
          
        System.out.printf("Name: %s  Age: %d  Height: %.2f \n", name, age, height);
    }
}
```
При выводе чисел с плавающей точкой мы можем указать количество знаков после запятой, для этого используем спецификатор на %.2f, где .2 указывает, что после запятой будет два знака. В итоге мы получим следующий вывод:

## Что такое библиотеки классов Java?
В Java есть виртуальная библиотека протестированного кода - уже готовые решения ко многим задачам, которые стоят перед программистами в их ежедневной работе.

В этой виртуальной библиотеке Java информация разбита по пакетам ("packages") - это своеобразный аналог полочек в книжном магазине. В каждом пакете протестированный код по какому-то отдельно взятому направлению.

Например, есть такие пакеты:

java.applet
java.lang  - это основной пакет языка Java
java.util
java.io
java.net
и т.д.

Все пакеты Вы можете найти на сайте Oracle по ссылке: https://docs.oracle.com/javase/8/docs/api

В пакете лежат классы. 

В классе есть методы (действия), которые мы можем выполнять с помощью класса. 
Например, в классе Math есть такие методы:

sqrt () - выведение квадратного корня
sin () - вычисление синуса угла
cos () - вычисление косинуса угла
и т.д.

То есть, если нам необходимо посчитать квадратный корень, нам не надо писать код, который пошагово программировал бы вычисление квадратного корня. А такой код бы потянул на очень и очень много строк кода... А мы просто берём из пакета java.lang класс Math, а в нём метод который нам нужен для вычисления квадратного корня sqrt () и всё  - в одну строчку кода мы получим нужное нам решение.
```java
    int age = 30;
    System.out.printf("Sqrt of age: %.2f \n", Math.sqrt(age));

```
## Ввод с консоли
Для получения ввода с консоли в классе System определен объект in. Однако непосредственно через объект System.in не очень удобно работать, поэтому, как правило, используют класс Scanner, который, в свою очередь использует System.in. Например, напишем маленькую программу, которая осуществляет ввод чисел:
```java
import java.util.Scanner; // импорт сканнера
 
public class Program {
   
    public static void main(String[] args) {
           
        Scanner in = new Scanner(System.in); // объявить сканер
        System.out.print("Input a number: ");
        int num = in.nextInt(); // считать число с консоли
          
        System.out.printf("Your number: %d \n", num);
        in.close();
    }
}
```
Так как класс Scanner находится в пакете java.util, то мы вначале его импортируем с помощью инструкции import java.util.Scanner.

Для создания самого объекта Scanner в его конструктор передается объект System.in. После этого мы можем получать вводимые значения. Например, в данном случае вначале выводим приглашение к вводу и затем получаем вводимое число в переменную num.

Чтобы получить введенное число, используется метод in.nextInt();, который возвращает введенное с клавиатуры целочисленное значение.

Класс Scanner имеет еще ряд методов, которые позволяют получить введенные пользователем значения:

- next(): считывает введенную строку до первого пробела
- nextLine(): считывает всю введенную строку
- nextInt(): считывает введенное число int
- nextDouble(): считывает введенное число double
- nextBoolean(): считывает значение boolean
- nextByte(): считывает введенное число byte
- nextFloat(): считывает введенное число float
- nextShort(): считывает введенное число short

То есть для ввода значений каждого примитивного типа в классе Scanner определен свой метод.
Например, создадим программу для ввода информации о человеке:
```java
import java.util.Scanner;
 
public class Program {
   
    public static void main(String[] args) {
           
        Scanner in = new Scanner(System.in);
        System.out.print("Input name: ");
        String name = in.nextLine();
        System.out.print("Input age: ");
        int age = in.nextInt();
        System.out.print("Input height: ");
        float height = in.nextFloat();
        System.out.printf("Name: %s  Age: %d  Height: %.2f \n", name, age, height);
        in.close();
    }
}
```
Здесь последовательно вводятся данные типов String, int, float и потом все введенные данные вместе выводятся на консоль.
для ввода значения типа float (то же самое относится к типу double) применяется число "1,7", где разделителем является запятая, а не "1.7", где разделителем является точка. В данном случае все зависит от текущей языковой локализации системы. 

## метод next ()
Допустим, Вы хотите, чтоб пользователь ввёл любое слово или фразу. И при этом, чтобы программа вывела в консоль всё до первого пробела.

Например, если пользователь введёт "Работа со сканнером - это круто", программа прочитает только слово "Работа". Потому что первый пробел появляется после слова "работа".

Или если пользователь, например, введёт "Я люблю Java", программа прочитает только слово "Я". Потому что первый пробел появляется после слова "Я".
```java
import java.util.Scanner; // импорт сканера

public class Test {
    public static void main(String[] args) {

        Scanner sc = new Scanner(System.in);
        System.out.println("Введите любое слово или фразу: ");
        String phrase1 = sc.next();
        System.out.println(phrase1);
    }
}
```

С помощью String phrase1 мы объявили переменную с именем phrase1, относящуюся к типу String. = sc. next ();  считывает введенное пользователем слово или фразу с консоли до первого пробела. 

## Переменные
Переменные объявляются следующим образом: тип_данных имя_переменной;

## Ключевое слово var
Начиная с Java 10 в язык было добавлено ключевое слово var, которое также позволяет определять переменную:
```java
var x = 10;
System.out.println(x);  // 10
```
Слово var ставится вместо типа данных, а сам тип переменной выводится из того значения, которое ей присваивается. Например, переменной x присваивается число 10, значит, переменная будет представлять тип int.

Но если переменная объявляется с помощью var, то мы обязательно должны инициализировать ее, то есть предоставить ей начальное значение, иначе мы получим ошибку, как, например, в следующем случае:
```java
var x;      // ! Ошибка, переменная не инициализирована
x = 10;
```
## Константы в Java
Кроме переменных, в Java для хранения данных можно использовать константы. В отличие от переменных константам можно присвоить значение только один раз. Константа объявляется также, как и переменная, только вначале идет ключевое слово final:
```java

final int LIMIT = 5;
System.out.println(LIMIT);  // 5
// LIMIT=57; // так мы уже не можем написать, так как LIMIT - константа
```
Как правило, константы имеют имена в верхнем регистре.

Константы позволяют задать такие переменные, которые не должны больше изменяться. Например, если у нас есть переменная для хранения числа pi, то мы можем объявить ее константой, так как ее значение постоянно.

Как объявлять и использовать константы в Java
1. Для того, чтобы переменную сделать константой, необходимо использовать ключевое слово final.
2. Константы в программе принято писать большими буквами, чтобы отличать их от обычных переменных.
3. Если в программе происходит попытка изменить константу, компилятор javac выдаст сообщение об ошибке. Потому что значение константы Вы можете задать только 1 раз.

### Вычислить периметр круга

Задача: Вычислить периметр круга при разных значениях радиуса:

R = 10 см
R = 25 см

Решение:

Периметр круга вычисляется по формуле:  P= 2πR
P - Периметр круга (длина окружности)
π - число пи (3.1415)
R - радиус круга (окружности)
```java
class Test {

    public static void main(String[] args) {
        final double Pi = 3.1415926536;
        // Константа Pi с типом данных для чисел c плавающей точкой
        double lengthl = 2*Pi*10;
        double length2 = 2*Pi*25;
        System.out.println ("Периметр круга при радиусе 10 см равен " + lengthl + ", а при радиусе 25 см равен " + length2);
    }
}
```
## Логический тип boolean
Каждый оператор сравнения в Java возвращает булевскую переменную (boolean), которая может принять только два значения: true (истина) или false (ложь).
```java
boolean b = false;
b = true;

boolean toBe = false;
b = toBe || !toBe;
if (b) {
    System.out.println(toBe);
}
```
Оператор || это логическое «или».

А например, такой код не будет работать по причине несовместимости типов:
```java
int children = 0;
b = children;  // Не будет работать, требуется boolean, а найден int
if (children) {  // Не будет работать, требуется boolean, а найден int
    // Не будет работать, требуется boolean, а найден int
}
```

## Условные выражения
 
Условные выражения представляют собой некоторое условие и возвращают значение типа boolean, то есть значение true (если условие истинно), или значение false (если условие ложно). К условным выражениям относятся операции сравнения и логические операции.

### Операции сравнения
В операциях сравнения сравниваются два операнда, и возвращается значение типа boolean - true, если выражение верно, и false, если выражение неверно.
- == - сравнивает два операнда на равенство и возвращает true (если операнды равны) и false (если операнды не равны)
```java
int a = 10;
int b = 4;
boolean c = a == b;         // false
boolean d = a == 10;       // true
```
### Операторы == и equals
Оператор == работает немного по-другому на объектах, нежели на примитивах. Когда вы используем объекты и хотите проверить, равны ли они, оператор == скажет что они равны, только если объекты одинаковы, но если вы хотите проверить их на логическое соответствие, используйте метод equals. Например:
```java

String a = new String("Wow");
String b = new String("Wow");
String sameA = a;

boolean r1 = a == b;      // Ложь, так как a и b не один и тот же объект
boolean r2 = a.equals(b); // Истина, так как a и b логически равны
boolean r3 = a == sameA;  // Истина, так как a и sameA действительно один и тот же объект

```
- != - сравнивает два операнда и возвращает true, если операнды НЕ равны, и false, если операнды равны
```java
int a = 10;
int b = 4;
boolean c = a != b;         // true
boolean d = a != 10;       // false
```
- < (меньше чем) Возвращает true, если первый операнд меньше второго, иначе возвращает false
```java

int a = 10;
int b = 4;
boolean c = a < b;   // false

```
- > (больше чем) Возвращает true, если первый операнд больше второго, иначе возвращает false
```java

int a = 10;
int b = 4;
boolean c = a > b;   // true

```
- >= (больше или равно) Возвращает true, если первый операнд больше второго или равен второму, иначе возвращает false
```java

boolean c = 10 >= 10;    // true
boolean b = 10 >= 4;     // true
boolean d = 10 >= 20;    // false

```
- <= (меньше или равно) Возвращает true, если первый операнд меньше второго или равен второму, иначе возвращает false
```java

boolean c = 10 <= 10;    // true
boolean b = 10 <= 4;     // false
boolean d = 10 <= 20;    // true

```

## Логические операторы

### & (логическое умножение)

Умножение производится поразрядно, и если у обоих операндов значения разрядов равно 1, то операция возвращает 1, иначе возвращается число 0:
```java
   c=a&b; (c равно true, если и a, и b равны true, иначе c будет равно false)

   int a1 = 2; //010
   int b1 = 5;//101
   System.out.println(a1&b1); // результат 0
   // В первом случае у нас два числа 2 и 5. 2 в двоичном виде представляет число 010, а 5 - 101. Поразрядное умножение чисел (0*1, 1*0, 0*1) дает результат 000.

    int a2 = 4; //100
    int b2 = 5; //101
    System.out.println(a2 & b2); // результат 4
    // Во втором случае у нас вместо двойки число 4, у которого в первом разряде 1, так же как и у числа 5, поэтому здесь результатом операции (1*1, 0*0, 0 *1) = 100 будет число 4 в десятичном формате.

```
### | (логическое сложение)
Данная операция также производится по двоичным разрядам, но теперь возвращается единица, если хотя бы у одного числа в данном разряде имеется единица (операция "логическое ИЛИ"):
```java
c=a|b; (c равно true, если либо a, либо b (либо и a, и b) равны true, иначе c будет равно false)

int a1 = 2; //010
int b1 = 5;//101
System.out.println(a1|b1); // результат 7 - 111
int a2 = 4; //100
int b2 = 5;//101
System.out.println(a2 | b2); // результат 5 - 101
```
### ^ (логическое исключающее ИЛИ)
Также эту операцию называют XOR, нередко ее применяют для простого шифрования:
```java
c=a^b; (c равно true, если либо a, либо b (но не одновременно) равны true, иначе c будет равно false)

int number = 45; // 1001 Значение, которое надо зашифровать - в двоичной форме 101101
int key = 102; //Ключ шифрования - в двоичной системе 1100110
int encrypt = number ^ key; //Результатом будет число 1001011 или 75
System.out.println("Зашифрованное число: " +encrypt);
 
int decrypt = encrypt ^ key; // Результатом будет исходное число 45
System.out.println("Расшифрованное число: " + decrypt);
```
Здесь также производятся поразрядные операции. Если у нас значения текущего разряда у обоих чисел разные, то возвращается 1, иначе возвращается 0. Например, результатом выражения 9^5 будет число 12. А чтобы расшифровать число, мы применяем обратную операцию к результату.

### ~ (логическое отрицание)

!: c=!b; (c равно true, если b равно false, иначе c будет равно false)

### Оператор ||

c=a||b; (c равно true, если либо a, либо b (либо и a, и b) равны true, иначе c будет равно false)

### Оператор &&
```java
c=a&&b; (c равно true, если и a, и b равны true, иначе c будет равно false)
```
Здесь у нас две пары операций | и || (а также & и &&) выполняют похожие действия, однако же они не равнозначны.

Выражение c=a|b; будет вычислять сначала оба значения - a и b и на их основе выводить результат.

В выражении же c=a||b; вначале будет вычисляться значение a, и если оно равно true, то вычисление значения b уже смысла не имеет, так как у нас в любом случае уже c будет равно true. Значение b будет вычисляться только в том случае, если a равно false

То же самое касается пары операций &/&&. В выражении c=a&b; будут вычисляться оба значения - a и b.

В выражении же c=a&&b; сначала будет вычисляться значение a, и если оно равно false, то вычисление значения b уже не имеет смысла, так как значение c в любом случае равно false. Значение b будет вычисляться только в том случае, если a равно true

Таким образом, операции || и && более удобны в вычислениях, позволяя сократить время на вычисление значения выражения и тем самым повышая производительность. А операции | и & больше подходят для выполнения поразрядных операций над числами.

## Примеры:

```java
int a = 4;
int b = 5;
boolean result;
result = a < b;  // истина result = a > b;  // ложь
result = a <= 4; // меньше или равно - истина result = b >= 6;  // больше или равно - ложь
result = a == b;  // равно - ложь
result = a != b;  // неравно - истина
result = a > b || a < b;  // логическое ИЛИ - истина
result = 3 < a && a < 6;  // логическое И - истина
result = !result;  // Логическое НЕ - ложь

boolean a1 = (5 > 6) || (4 < 6); // 5 > 6 - false, 4 < 6 - true, поэтому возвращается true
boolean a2 = (5 > 6) || (4 > 6); // 5 > 6 - false, 4 > 6 - false, поэтому возвращается false
boolean a3 = (5 > 6) && (4 < 6); // 5 > 6 - false, поэтому возвращается false (4 < 6 - true, но не вычисляется)
boolean a4 = (50 > 6) && (4 / 2 < 3); // 50 > 6 - true, 4/2 < 3 - true, поэтому возвращается true
boolean a5 = (5 > 6) ^ (4 < 6); // 5 > 6 - true, поэтому возвращается true (4 < 6 - false)
boolean a6 = (50 > 6) ^ (4 / 2 < 3); // 50 > 6 - true, 4/2 < 3 - true, поэтому возвращается false

```
## Преобразования базовых типов данных
 
Каждый базовый тип данных занимает определенное количество байт памяти. Это накладывает ограничение на операции, в которые вовлечены различные типы данных. 
```java
int a = 4;
byte b = a; // ! Ошибка

```
В данном коде мы столкнемся с ошибкой. Хотя и тип byte, и тип int представляют целые числа. Более того, значение переменной a, которое присваивается переменной типа byte, вполне укладывается в диапазон значений для типа byte (от -128 до 127). Тем не менее мы сталкиваемся с ошибкой на этапе компиляции. Поскольку в данном случае мы пытаемся присвоить некоторые данные, которые занимают 4 байта, переменной, которая занимает всего один байт.

Тем не менее в программе может потребоваться, чтобы подобное преобразование было выполнено. В этом случае необходимо использовать операцию преобразования типов (операция ()):
```java

int a = 4;
byte b = (byte)a;  // преобразование типов: от типа int к типу byte
System.out.println(b); // 4

```
Операция преобразования типов предполагает указание в скобках того типа, к которому надо преобразовать значение. Например, в случае операции (byte)a, идет преобразование данных типа int в тип byte. В итоге мы получим значение типа byte.

## Явные и неявные преобразования
Когда в одной операции вовлечены данные разных типов, не всегда необходимо использовать операцию преобразования типов. Некоторые виды преобразований выполняются неявно, автоматически.

## Автоматические преобразования
Автоматически без каких-либо проблем производятся расширяющие преобразования (widening) - они расширяют представление объекта в памяти. Например:
```java

byte b = 7;
int d = b;  // преобразование от byte к int

```
В данном случае значение типа byte, которое занимает в памяти 1 байт, расширяется до типа int, которое занимает 4 байта.

Расширяющие автоматические преобразования представлены следующими цепочками:
- byte -> short -> int -> long
- int -> double
- short -> float -> double
- char -> int

## Автоматические преобразования с потерей точности
Некоторые преобразования могут производиться автоматически между типами данных одинаковой разрядности или даже от типа данных с большей разрядностью к типа с меньшей разрядностью. Это следующие цепочки преобразований: int -> float, long -> float и long -> double. Они производятся без ошибок, но при преобразовании мы можем столкнуться с потерей информации.
```java

int a = 2147483647;
float b = a;            // от типа int к типу float
System.out.println(b);  // 2.14748365E9

```
## Явные преобразования
Во всех остальных преобразованиях примитивных типов явным образом применяется операция преобразования типов. Обычно это сужающие преобразования (narrowing) от типа с большей разрядностью к типу с меньшей разрядностью:
```java

long a = 4;
int b = (int) a;

```
## Потеря данных при преобразовании
При применении явных преобразований мы можем столкнуться с потерей данных. Например, в следующем коде у нас не возникнет никаких проблем:
```java

int a = 5;
byte b = (byte) a;
System.out.println(b);      // 5

```
Число 5 вполне укладывается в диапазон значений типа byte, поэтому после преобразования переменная b будет равна 5. Но что будет в следующем случае:
```java

int a = 258;
byte b = (byte) a;
System.out.println(b);      // 2

```
Результатом будет число 2. В данном случае число 258 вне диапазона для типа byte (от -128 до 127), поэтому произойдет усечение значения. Почему результатом будет именно число 2?

Число a, которое равно 258, в двоичном системе будет равно 00000000 00000000 00000001 00000010. Значения типа byte занимают в памяти только 8 бит. Поэтому двоичное представление числа int усекается до 8 правых разрядов, то есть 00000010, что в десятичной системе дает число 2.

## Усечение рациональных чисел до целых
При преобразовании значений с плавающей точкой к целочисленным значениям, происходит усечение дробной части:
```java

double a = 56.9898;
int b = (int)a;

```
Здесь значение числа b будет равно 56, несмотря на то, что число 57 было бы ближе к 56.9898. Чтобы избежать подобных казусов, надо применять функцию округления, которая есть в математической библиотеке Java:
```java

double a = 56.9898;
int b = (int)Math.round(a);

```
## Преобразования при операциях
Нередки ситуации, когда приходится применять различные операции, например, сложение и произведение, над значениями разных типов. Здесь также действуют некоторые правила:
- если один из операндов операции относится к типу double, то и второй операнд преобразуется к типу double
- если предыдущее условие не соблюдено, а один из операндов операции относится к типу float, то и второй операнд преобразуется к типу float
- если предыдущие условия не соблюдены, один из операндов операции относится к типу long, то и второй операнд преобразуется к типу long
- иначе все операнды операции преобразуются к типу int

Примеры преобразований:
```java
int a = 3;
double b = 4.6;
double c = a+b;
// Так как в операции участвует значение типа double, то и другое значение приводится к типу double и сумма двух значений a+b будет представлять тип double.

// Другой пример:
byte a = 3;
short b = 4;
byte c = (byte)(a+b);
```
Две переменных типа byte и short (не double, float или long), поэтому при сложении они преобразуются к типу int, и их сумма a+b представляет значение типа int. Поэтому если затем мы присваиваем эту сумму переменной типа byte, то нам опять надо сделать преобразование типов к byte.

Если в операциях участвуют данные типа char, то они преобразуются в int:
```java

int d = 'a' + 5;
System.out.println(d);  // 102

```
## Условные конструкции
Одним из фундаментальных элементов многих языков программирования являются условные конструкции. Данные конструкции позволяют направить работу программы по одному из путей в зависимости от определенных условий.

В языке Java используются следующие условные конструкции: if..else и switch..case

## Конструкция if/else
Java использует булевские (логические) переменные, чтобы оценивать условия. Значение true или false возвратится, после того как выражение будет оценено. Например:
```java
int a = 4;
if (a == 4) {
    System.out.println("Ohhh! So a is 4!");
}
```

Синтаксис оператора if — else довольно прост:
```java
if (a == b) {
    // Тело метода. Выполняется если a и b равны.
}
```
Так же мы можем добавить еще одно выражение, на случай, если условие не выполняется:
```java
if (a == b) {
    // Мы уже знаем эту часть
} else {
    // a и b не равны... :/
}
```
Если тело метода можно разместить в одну строку, можно не использовать { }
```java


if (a == b) System.out.println("Yeah!");
else System.out.println("Ohhh...");
```
Или
```java
if (a == b)
    System.out.println("Another line Wow!");
else
    System.out.println("Double rainbow!");
```

Выражение if/else проверяет истинность некоторого условия и в зависимости от результатов проверки выполняет определенный код:
```java
int num1 = 6;
int num2 = 4;
if(num1>num2){
    System.out.println("Первое число больше второго");
}
```
После ключевого слова if ставится условие. И если это условие выполняется, то срабатывает код, который помещен в далее в блоке if после фигурных скобок. В качестве условий выступает операция сравнения двух чисел.

добавить блок else:
```java
int num1 = 6;
int num2 = 4;
if(num1>num2){
    System.out.println("Первое число больше второго");
}
else{
    System.out.println("Первое число меньше второго");
}
```
Но при сравнении чисел мы можем насчитать три состояния: первое число больше второго, первое число меньше второго и числа равны. С помощью выражения else if, мы можем обрабатывать дополнительные условия:
```java
int num1 = 6;
int num2 = 8;
if(num1>num2){
    System.out.println("Первое число больше второго");
}
else if(num1<num2){
    System.out.println("Первое число меньше второго");
}
else{
    System.out.println("Числа равны");
}
Также мы можем соединить сразу несколько условий, используя логические операторы:

int num1 = 8;
int num2 = 6;
if(num1 > num2 && num1>7){
    System.out.println("Первое число больше второго и больше 7");
}
```
Здесь блок if будет выполняться, если num1 > num2 равно true и одновременно num1>7 равно true.

## Другая сторона if
Есть еще один способ записать if — else в одну строку — с помощью оператора ? :
```java
int a = 4;
int result = a == 4 ? 1 : 8;
// result будет равен 1
// Или обычная форма записи:
int result;
if (a == 4) {
    result = 1;
} else {
    result = 8;
}
```
## Оператор switch
Оператор switch (или ещё называется ветвление с помощью переключателей)
Конструкции с операторами if else, предлагающими большое количество условных ветвлений, могут выглядеть очень громоздкими. Поэтому в тех случаях, когда необходимо повторять проверку одного и того же значения переменной, есть более элегантное решение с помощью оператора switch.

### Общая форма оператора switch
```java
switch (проверяемая-переменная){
case значение1: 
    код-для-высполнения-при-переменная==значение1;
    break;
case значение2: 
    код-для-высполнения-при-переменная==значение2;
    break;
case значение3: 
    код-для-высполнения-при-переменная==значение3;
    break;
default: 
    код-для-выполнения-если-значение-переменной-не-предусмотрено-в-case;
}

```
Конструкция switch/case аналогична конструкции if/else, так как позволяет обработать сразу несколько условий:
```java
int num = 8;
switch(num){
             
    case 1: 
        System.out.println("число равно 1");
        break;
    case 8: 
        System.out.println("число равно 8");
        num++;
        break;
    case 9: 
        System.out.println("число равно 9");
        break;
    default:
        System.out.println("число не равно 1, 8, 9");
}
```
После ключевого слова switch в скобках идет сравниваемое выражение. Значение этого выражения последовательно сравнивается со значениями, помещенными после операторов сase. И если совпадение найдено, то будет выполняет соответствующий блок сase.

В конце блока сase ставится оператор break, чтобы избежать выполнения других блоков. Например, если бы убрали оператор break в следующем случае:
```java
case 8: 
    System.out.println("число равно 8");
    num++;
case 9: 
    System.out.println("число равно 9");
    break;
```
то выполнился бы блок case 8, (поскольку переменная num равна 8). Но так как в этом блоке оператор break отсутствует, то начал бы выполняться блок case 9.

Если мы хотим также обработать ситуацию, когда совпадения не будет найдено, то можно добавить блок default, как в примере выше. Хотя блок default необязателен.

Также мы можем определить одно действие сразу для нескольких блоков case подряд:
```java
int num = 3;
int output = 0;
switch(num){
     
    case 1: 
        output = 3;
        break;
    case 2: 
    case 3: 
    case 4: 
        output = 6;
        break;
    case 5: 
        output = 12;
        break;
    default:
        output = 24;
}
System.out.println(output);

```
## Тернарная операция
Тернарную операция имеет следующий синтаксис:
 [первый операнд - условие] ? [второй операнд] : [третий операнд]. 
Таким образом, в этой операции участвуют сразу три операнда. В зависимости от условия тернарная операция возвращает второй или третий операнд: если условие равно true, то возвращается второй операнд; если условие равно false, то третий. Например:
```java
int x=3;
int y=2;
int z = x<y? (x+y) : (x-y);
System.out.println(z);
// Здесь результатом тернарной операции является переменная z. Сначала проверяется условие x<y. И если оно соблюдается, то z будет равно второму операнду - (x+y), иначе z будет равно третьему операнду.

```