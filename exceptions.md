# Обработка исключений

Исключениями или исключительными ситуациями (состояниями) называются ошибки, возникшие в программе во время её работы.
Все исключения в Java являются объектами. Поэтому они могут порождаться не только автоматически при возникновении исключительной ситуации, но и создаваться самим разработчиком.

К механизму обработки исключений в Java имеют отношение 5 ключевых слов: — try, catch, throw, throws и finally. Схема работы этого механизма следующая. Вы пытаетесь (try) выполнить блок кода, и если при этом возникает ошибка, система возбуждает (throw) исключение, которое в зависимости от его типа вы можете перехватить (catch) или передать умалчиваемому (finally) обработчику.

## общая форма блока обработки исключений.
```java

try {

// блок кода }

catch (ТипИсключения1 е) {

// обработчик исключений типа ТипИсключения1 }

catch (ТипИсключения2 е) {

// обработчик исключений типа ТипИсключения2

 throw(e)   // повторное возбуждение исключения }

finally {

}
```

## конструкция try...catch...finally. 

При возникновении исключения в блоке try управление переходит в блок catch, который может обработать данное исключение. Если такого блока не найдено, то пользователю отображается сообщение о необработанном исключении, а дальнейшее выполнение программы останавливается. И чтобы подобной остановки не произошло, и надо использовать блок try..catch:
```java

int[] numbers = new int[3];
numbers[4]=45;
System.out.println(numbers[4]);

// Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: Index 4 out of bounds for length 3 at ua.mycom.Main.main(Main.java:14)
```

Так как у нас массив numbers может содержать только 3 элемента, то при выполнении инструкции numbers[4]=45 консоль отобразит исключение, и выполнение программы будет завершено. 

Теперь попробуем обработать это исключение:
```java

try{
    int[] numbers = new int[3];
    numbers[4]=45;
    System.out.println(numbers[4]);
}
catch(Exception ex){
     
    ex.printStackTrace();
}
System.out.println("Программа завершена");

```
При использовании блока try...catch вначале выполняются все инструкции между операторами try и catch. Если в блоке try вдруг возникает исключение, то обычный порядок выполнения останавливается и переходит к инструкции сatch. Поэтому когда выполнение программы дойдет до строки numbers[4]=45;, программа остановится и перейдет к блоку catch

## Выражение catch
Выражение catch имеет следующий синтаксис: catch (тип_исключения имя_переменной). 
В данном случае объявляется переменная ex, которая имеет тип Exception. Но если возникшее исключение не является исключением типа, указанного в инструкции сatch, то оно не обрабатывается, а программа просто зависает или выбрасывает сообщение об ошибке.

Но так как тип Exception является базовым классом для всех исключений, то выражение catch (Exception ex) будет обрабатывать практически все исключения. 

## стек трассировки ошибки
Обработка исключения в данном случае сводится к выводу на консоль стека трассировки ошибки с помощью метода printStackTrace(), определенного в классе Exception.

После завершения выполнения блока catch программа продолжает свою работу, выполняя все остальные инструкции после блока catch.

Конструкция try..catch также может иметь блок finally. Однако этот блок необязательный, и его можно при обработке исключений опускать. Блок finally выполняется в любом случае, возникло ли исключение в блоке try или нет:

```java

try{
    int[] numbers = new int[3];
    numbers[4]=45;
    System.out.println(numbers[4]);
}
catch(Exception ex){
     
    ex.printStackTrace();
}
finally{
    System.out.println("Блок finally");
}
System.out.println("Программа завершена");

```

## Неперехваченные исключения

Объекты-исключения автоматически создаются исполняющей средой Java в результате возникновения определенных исключительных состояний. Например, очередная наша программа содержит выражение, при вычислении которого возникает деление на нуль.
```java

public static void main(string args[]) {

int d = 0;
int a = 42 / d;

}

```
## ArithmeticException
Обратите внимание на тот факт что типом возбужденного исключения был не Exception и не Throwable. Это подкласс класса Exception, а именно: ArithmeticException, поясняющий, какая ошибка возникла при выполнении программы. 

Сразу же после try-блока помещается блок catch, задающий тип исключения которое вы хотите обрабатывать.
```java

    public static void main(String args[]) {

        try {
            int d = 0;
             int a = 42 / d;
            }

        catch (ArithmeticException e) {
            System.out.println("division by zero");
        }
    } 

```

Целью большинства хорошо сконструированных catch-разделов должна быть обработка возникшей исключительной ситуации и приведение переменных программы в некоторое разумное состояние — такое, чтобы программу можно было продолжить так, будто никакой ошибки и не было (в нашем примере выводится предупреждение – division by zero).


Вот другая версия того же класса, в которой возникает та же исключительная ситуация, но на этот раз не в программном коде метода main.
```java

class Exc1 {

    static void subroutine() {

    int d = 0;

    int a = 10 / d;

}

public static void main(String args[]) {

    Exc1.subroutine();

}

// Вывод этой программы показывает, как обработчик исключений исполняющей системы Java выводит содержимое всего стека вызовов.

// java.lang.ArithmeticException: / by zero
// at Exc1.subroutine(Exc1.java:4)
// at Exc1.main(Exc1.java:7)

```

## Несколько разделов catch

В некоторых случаях один и тот же блок программного кода может возбуждать исключения различных типов. Для того, чтобы обрабатывать подобные ситуации, Java позволяет использовать любое количество catch-разделов для try-блока. Наиболее специализированные классы исключений должны идти первыми, поскольку ни один подкласс не будет достигнут, если поставить его после суперкласса. Следующая программа перехватывает два различных типа исключений, причем за этими двумя специализированными обработчиками следует раздел catch общего назначения, перехватывающий все подклассы класса Throwable.

```java

public static void main(String args[]) {

    try {
         int a = args.length;
         System.out.println("a = " + a);
         int b = 42 / a;
         int c[] = { 1 };
         c[42] = 99;
    }

    catch (ArithmeticException e) {
        System.out.println("div by 0: " + e);
    }

    catch(ArrayIndexOutOfBoundsException e) {
        System.out.println("array index oob: " + e);
    }

} 

// Этот пример, запущенный без параметров, вызывает возбуждение исключительной ситуации деления на нуль. Если же мы зададим в командной строке один или несколько параметров, тем самым установив а в значение больше нуля, наш пример переживет оператор деления, но в следующем операторе будет возбуждено исключение выхода индекса за границы массива ArrayIndexOutOf Bounds. 

// а = 0
// div by 0: java.lang.ArithmeticException: / by zero

// a = 1
// array index oob: java.lang.ArrayIndexOutOfBoundsException: 42

```

## Обработка нескольких исключений
В Java имеется множество различных типов исключений, и мы можем разграничить их обработку, включив дополнительные блоки catch:
```java

int[] numbers = new int[3];

try{
    numbers[6]=45;
    numbers[6]=Integer.parseInt("gfd");
}
catch(ArrayIndexOutOfBoundsException ex){
             
    System.out.println("Выход за пределы массива");
}
catch(NumberFormatException ex){
             
    System.out.println("Ошибка преобразования из строки в число");
}

```
Если у нас возникает исключение определенного типа, то оно переходит к соответствующему блоку catch.

## несколько блоков catch
Одному try может соответствовать сразу несколько блоков catch с разными классами исключений.
```java

import java.util.Scanner; 
class Main { 
    public static void main(String[] args) { 
     int[] m = {-1,0,1}; 
        Scanner sc = new Scanner(System.in); 
        try { 
            int a = sc.nextInt();     
            m[a] = 4/a; 
            System.out.println(m[a]); 
        } catch (ArithmeticException e) { 
            System.out.println("Произошла недопустимая арифметическая операция"); 
        } catch (ArrayIndexOutOfBoundsException e) { 
            System.out.println("Обращение по недопустимому индексу массива"); 
        } 
    } 
}

```
Если запустив представленную программу, пользователь введётся с клавиатуры 1 или 2, то программа отработает без создания каких-либо исключений.

Если пользователь введёт 0, то возникнет исключение класса ArithmeticException, и оно будет обработано первым блоком catch.

Если пользователь введёт 3, то возникнет исключение класса ArrayIndexOutOfBoundsException (выход за приделы массива), и оно будет обработано вторым блоком catch.

Если пользователь введёт нецелое число, например, 3.14, то возникнет исключение класса InputMismatchException (несоответствие типа вводимого значение), и оно будет выброшено в формате стандартной ошибки, поскольку его мы никак не обрабатывали.

Можно добавить обработчик для класса Exception, поскольку этот класс родительский для всех остальных контролируемых исключений, то он будет перехватывать любые из них (в том числе, и InputMismatchException).
```java

import java.util.Scanner; 
class Main { 
    public static void main(String[] args) { 
        int[] m = {-1,0,1}; 
        int a = 1; 
        Scanner sc = new Scanner(System.in);        
        try { 
            a = sc.nextInt();     
            m[a-1] = 4/a;
            System.out.println(m[a]); 
        } catch (ArithmeticException e) { 
            System.out.println("Произошла недопустимая арифметическая операция"); 
        } catch (ArrayIndexOutOfBoundsException e) { 
            System.out.println("Обращение по недопустимому индексу массива");       
        } catch (Exception e) { 
            System.out.println("Произошло ещё какое-то исключение"); 
        } 
    } 
}

```
Поскольку исключения построены на иерархии классов и подклассов, то сначала надо пытаться обработать более частные исключения и лишь затем более общие. То есть поставив первым (а не третьим) блок с обработкой исключения класса Exception, мы бы никогда не увидели никаких сообщений об ошибке, кроме «Произошло ещё какое-то исключение» (все исключения перехватились бы сразу этим блоком и не доходили бы до остальных).

Необязательным добавлением к блокам try…catch может быть блок finally. Помещенные в него команды будут выполняться в любом случае, вне зависимости от того, произошло ли исключение или нет. При том, что при возникновении необработанного исключения оставшаяся после генерации этого исключения часть программы — не выполняется. Например, если исключение возникло в процессе каких-то длительных вычислений, в блоке finally можно показать или сохранить промежуточные результаты.


## Вложенные операторы try
Операторы try можно вкладывать друг в друга аналогично тому, как можно создавать вложенные области видимости переменных. Если у оператора try низкого уровня нет раздела catch, соответствующего возбужденному исключению, стек будет развернут на одну ступень выше, и в поисках подходящего обработчика будут проверены разделы catch внешнего оператора try. 


пример, в котором два оператора try вложены друг в друга посредством вызова метода.
 
```java

class Main {

    static void procedure() {
        try {
             int c[] = { 1 };
             c[42] = 99;
        }
        catch(ArrayIndexOutOfBoundsException e) {
            System.out.println("array index oob: " + e);
        } 
    }

public static void main(String args[]) {

     try {
            int len = args.length;
            System.out.println("a = " + len);
            int b = 42 / len;
            procedure();
       }
       catch (ArithmeticException e) {
           System.out.println("div by 0: " + e);
       }

    } 
}

```

## Оператор throw

Оператор throw используется для возбуждения исключения вручную. Для того, чтобы сделать это, нужно иметь объект подкласса класса Throwable, который можно либо получить как параметр оператора catch, либо создать с помощью оператора new. 
```java

// общая форма оператора throw.

throw ОбъектТипаThrowable;

``` 
с помощью этого оператора мы сами можем создать исключение и вызвать его в процессе выполнения. Например, в нашей программе происходит ввод числа, и мы хотим, чтобы, если число больше 30, то возникало исключение:
```java 
import java.util.Scanner;

public class Main {
 
    public static void main(String[] args) {
        
        try{
            Scanner in = new Scanner(System.in);
            int x = in.nextInt();
            if(x>=30){
               throw new Exception("Число х должно быть меньше 30");
           }
        }
        catch(Exception ex){
             
            System.out.println(ex.getMessage());
        }
        System.out.println("Программа завершена");
    }   
}
```
Здесь для создания объекта исключения используется конструктор класса Exception, в который передается сообщение об исключении. И если число х окажется больше 29, то будет выброшено исключение и управление перейдет к блоку catch.

В блоке catch мы можем получить сообщение об исключении с помощью метода getMessage().

При достижении этого оператора нормальное выполнение кода немедленно прекращается, так что следующий за ним оператор не выполняется. Ближайший окружающий блок try проверяется на наличие соответствующего возбужденному исключению обработчика catch. Если такой отыщется, управление передается ему. Если нет, проверяется следующий из вложенных операторов try, и так до тех пор пока либо не будет найден подходящий раздел catch, либо обработчик исключений исполняющей системы Java не остановит программу, выведя при этом состояние стека вызовов. 

```java

// метод вычисления факториала, и нам надо обработать ситуацию, если в метод передается число меньше 1:

public static int getFactorial(int num) throws Exception{
     
    if(num<1) throw new Exception("The number is less than 1");
    int result=1;
    for(int i=1; i<=num;i++){
             
        result*=i;
    }
    return result;
}

```
С помощью оператора throw по условию выбрасывается исключение. В то же время метод сам это исключение не обрабатывает с помощью try..catch, поэтому в определении метода используется выражение throws Exception.

Теперь при вызове этого метода нам обязательно надо обработать выбрасываемое исключение:
```java

public static void main(String[] args){
         
    try{
        int result = getFactorial(-6);
         
        System.out.println(result);
    }
    catch(Exception ex){
         
        System.out.println(ex.getMessage());
    }
} 

```
Без обработки исключение у нас возникнет ошибка компиляции, и мы не сможем скомпилировать программу.

В качестве альтернативы мы могли бы и не использовать оператор throws, а обработать исключение прямо в методе:
```java

public static int getFactorial(int num){
     
    int result=1;
    try{
        if(num<1) throw new Exception("The number is less than 1");
         
        for(int i=1; i<=num;i++){
             
            result*=i;
        }
    }
    catch(Exception ex){
         
        System.out.println(ex.getMessage());
        result=num;
    }
    return result;
}

```

Если метод способен возбуждать исключения, которые он сам не обрабатывает, он должен объявить о таком поведении, чтобы вызывающие методы могли защитить себя от этих исключений. Для задания списка исключений, которые могут возбуждаться методом, используется ключевое слово throws. 

Если метод в явном виде (т.е. с помощью оператора throw) возбуждает исключение соответствующего класса, тип класса исключений должен быть указан в операторе throws в объявлении этого метода. С учетом этого наш прежний синтаксис определения метода должен быть расширен следующим образом:
```java
тип имя_метода(список аргументов) throws список_исключений {}
```

пример программы, в которой метод procedure пытается возбудить исключение, не обеспечивая ни программного кода для его перехвата, ни объявления этого исключения в заголовке метода. 
```java

// Такой программный код не будет оттранслирован.

public class Main {
    
    public static void main(String[] args) {
        procedure();
    }

    static void procedure() {
        System.out.println("inside procedure");
        throw new IllegalAccessException("demo");
    }
}

```

## исключения типа IllegalAccessException
Для того, чтобы мы смогли оттранслировать этот пример, нам придется сообщить транслятору, что procedure может возбуждать исключения типа IllegalAccessException и в методе main добавить код для обработки этого типа исключений :

```java

public class Main {
    
    static void procedure() throws IllegalAccessException {
        System.out.println(" inside procedure");
        throw new IllegalAccessException("demo");
    }

    public static void main(String args[]) {
        try {
        procedure();
        }
        catch (IllegalAccessException e) {
            System.out.println("caught " + e);
        }
    }
}

```

## исключение java.lang.NullPointerException
В Java исключение java.lang.NullPointerException генерируется, когда осуществляется доступ к ссылочной переменной (или отменяется ссылка на нее) и она не указывает на какой-либо объект. Эту ошибку можно устранить, используя блок try-catch или условие if-else, чтобы проверить, является ли ссылочная переменная нулевой, прежде чем разыменовать ее.

В некоторых случаях компилятор предотвращает это исключение с помощью ошибки времени компиляции Возможно, переменная не была инициализирована, когда в качестве аргумента метода передается пустая ссылочная переменная:
```java

String s;
foo (s); // Компилятор выдает ошибку.

```
Однако компилятор не выдает эту ошибку, когда значение null передается функции напрямую; 
Однако вероятность того, что это вызовет исключение NullPointerException, выше:

foo (ноль); // Более высокая вероятность исключения
```java
public class Main {
    
    public static void main(String[] args) {
        String s = "abcd";

        foo(null);
        bar(null);
    }

    // Using a try-catch block:
    static void foo(String x){
        try {
            System.out.println("First character: " + x.charAt(0));
        }
        catch(NullPointerException e) {
            System.out.println("NullPointerException thrown!");
        }
    }

    // Using if-else condition:
    static void bar(String x){
        if(x != null)
            System.out.println("First character: " + x.charAt(0));
        else
            System.out.println("NullPointerException thrown!");
    }
}
```

## Блок finally

Иногда требуется гарантировать, что определенный участок кода будет выполняться независимо от того, какие исключения были возбуждены и перехвачены. Для создания такого участка кода используется ключевое слово finally. Даже в тех случаях, когда в методе нет соответствующего возбужденному исключению раздела catch, блок finally будет выполнен до того, как управление перейдет к операторам, следующим за разделом try. У каждого раздела try должен быть по крайней мере или один раздел catch или блок finally. Блок finally очень удобен для закрытия файлов и освобождения любых других ресурсов, захваченных для временного использования в начале выполнения метода. Ниже приведен пример класса с двумя методами, завершение которых происходит по разным причинам, но в обоих перед выходом выполняется код раздела finally.

```java
package ua.mycom;

public class Main {
    
    static void procA() {
        try {
            System.out.println("inside procA");
            throw new RuntimeException("demo");
        }
        finally {
            System.out.println("procA's finally");
        } 
    }

    static void procB() {
        try {
            System.out.println("inside procB");
            return;
        }
        finally {
            System.out.println("procB's finally");
        } 
    }

    public static void main(String args[]) {

        try {
            procA();
        }
        catch (Exception e) {}
    
        procB();

    }
}

```

В этом примере в методе procA из-за возбуждения исключения происходит преждевременный выход из блока try, но по пути наружу выполняется раздел finally. Другой метод procB завершает работу выполнением стоящего в try-блоке оператора return, но и при этом перед выходом из метода выполняется программный код блока finally. Ниже приведен результат, полученный при выполнении этой программы.

## Классы исключений
 
Базовым классом для всех исключений является класс Throwable. От него уже наследуются два класса: Error и Exception. Все остальные классы являются производными от этих двух классов.

Исключения (Exceptions) являются результатом проблем в программе, которые в принципе решаемы и предсказуемы. Например, произошло деление на ноль в целых числах.

Класс Error описывает внутренние ошибки в исполняющей среде Java. Программист имеет очень ограниченные возможности для обработки подобных ошибок.

Ошибки представляют собой более серьёзные проблемы, которые, согласно спецификации Java, не следует пытаться обрабатывать в собственной программе, поскольку они связаны с проблемами уровня JVM. Например, исключения такого рода возникают, если закончилась память, доступная виртуальной машине. Программа дополнительную память всё равно не сможет обеспечить для JVM.

### исключения наследуются от класса Exception. 
Среди этих исключений следует выделить класс RuntimeException. RuntimeException является базовым классом для так называемой группы непроверяемых исключений (unchecked exceptions) - компилятор не проверяет факт обработки таких исключений и их можно не указывать вместе с оператором throws в объявлении метода. Такие исключения являются следствием ошибок разработчика, например, неверное преобразование типов или выход за пределы массива.

## Иерархия классов исключений в Java

В Java все исключения делятся на три типа: контролируемые исключения (checked) и неконтролируемые исключения (unchecked), к которым относятся ошибки (Errors) и исключения времени выполнения (RuntimeExceptions, потомок класса Exception).

Контролируемые исключения представляют собой ошибки, которые можно и нужно обрабатывать в программе, к этому типу относятся все потомки класса Exception (но не RuntimeException).

Неконтролируемые исключения не требуют обязательной обработки, однако, при желании, можно обрабатывать исключения класса RuntimeException.

## Некоторые из классов непроверяемых исключений:
- ArithmeticException: исключение, возникающее при делении на ноль
- IndexOutOfBoundException: индекс вне границ массива
- IllegalArgumentException: использование неверного аргумента при вызове метода
- NullPointerException: использование пустой ссылки
- NumberFormatException: ошибка преобразования строки в число

Все остальные классы, образованные от класса Exception, называются проверяемыми исключениями (checked exceptions).

## Некоторые из классов проверяемых исключений:
- CloneNotSupportedException: класс, для объекта которого вызывается клонирование, не реализует интерфейс Cloneable
- InterruptedException: поток прерван другим потоком
- ClassNotFoundException: невозможно найти класс

Подобные исключения обрабатываются с помощью конструкции try..catch. Либо можно передать обработку методу, который будет вызывать данный метод, указав исключения после оператора throws:
```java

public Person clone() throws CloneNotSupportedException{
    
    Person p = (Person) super.clone();
    return p;
}

```

## ArithmeticException:
```java

class Main { 
     public static void main(String[] args) { 
         int a = 4; 
         System.out.println(a/0); 
     } 
}
 

// В момент запуска на консоль будет выведено следующее сообщение:

// Exception in thread "main" java.lang.ArithmeticException: / by zero 
//         at Main.main(Main.java:4)

``` 
Из сообщения виден класс случившегося исключения — ArithmeticException. Это исключение можно обработать:
```java

class Main { 
     public static void main(String[] args) { 
         int a = 4; 
         try { 
              System.out.println(a/0); 
         } catch (ArithmeticException e) { 
              System.out.println("Произошла недопустимая арифметическая операция"); 
         } 
     } 
}
 

```
Теперь вместо стандартного сообщения об ошибке будет выполняться блок catch, параметром которого является объект eсоответствующего исключению класса (самому объекту можно давать любое имя, оно потребуется в том случае, если мы пожелаем снова принудительно выбросить это исключение, например, для того, чтобы оно было проверено каким-то ещё обработчиком).

В блок try при этом помещается тот фрагмент программы, где потенциально может возникнуть исключение.

Поскольку все классы исключений наследуются от класса Exception, то все они наследуют ряд его методов, которые позволяют получить информацию о характере исключения. Среди этих методов отметим наиболее важные:
- Метод getMessage() возвращает сообщение об исключении
- Метод getStackTrace() возвращает массив, содержащий трассировку стека исключения
- Метод printStackTrace() отображает трассировку стека

```java

try{
    int x = 6/0;
}
catch(Exception ex){
         
    ex.printStackTrace();
}

```

## Подклассы Exception
Только подклассы класса Throwable могут быть возбуждены или перехвачены. Простые типы — int, char и т.п., а также классы, не являющиеся подклассами Throwable, например, String и Object, использоваться в качестве исключений не могут. Наиболее общий путь для использования исключений — создание своих собственных подклассов класса Exception. 

## Создание своих классов исключений
 
Хотя имеющиеся в стандартной библиотеке классов Java классы исключений описывают большинство исключительных ситуаций, которые могут возникнуть при выполнении программы, все таки иногда требуется создать свои собственные классы исключений со своей логикой.

## Новый подкласс класса Exception.
В нем сделано объявление подкласса MyException класса Exception. У этого подкласса есть специальный конструктор, который записывает в переменную объекта целочисленное значение, и совмещенный метод toString, выводящий значение, хранящееся в объекте-исключении. Класс ExceptionDemo определяет метод compute, который возбуждает исключение типа MyExcepton. Простая логика метода compute возбуждает исключение в том случае, когда значение пара-ветра метода больше 10. Метод main в защищенном блоке вызывает метод compute сначала с допустимым значением, а затем — с недопустимым (больше 10), что позволяет продемонстрировать работу при обоих путях выполнения кода. 

```java
package ua.mycom;

class MyException extends Exception {

    private int detail;

    MyException(int a) 
    {
        detail = a;
    }
    
    public String toString() {
        return "MyException[" + detail + "]";
    }

}

public class Main {

    static void compute(int a) throws MyException {
        System.out.println("called computer a = " + a);
            if (a > 10)
                throw new MyException(a);
            System.out.println("normal exit.");
        }

    
    public static void main(String args[]) {

        try {
            compute(1);
            compute(20);
        }
        catch (MyException e) {
            System.out.println("caught" + e);
        }

    }
}

```

Чтобы создать свой класс исключений, надо унаследовать его от класса Exception. Например, у нас есть класс, вычисляющий факториал, и нам надо выбрасывать специальное исключение, если число, передаваемое в метод, меньше 1:
```java

class Factorial{
 
    public static int getFactorial(int num) throws FactorialException{
     
        int result=1;
        if(num<1) throw new FactorialException("The number is less than 1", num);
         
        for(int i=1; i<=num;i++){
             
            result*=i;
        }
        return result;
    }
}
 
class FactorialException extends Exception{
 
    private int number;
    public int getNumber(){return number;}
    public FactorialException(String message, int num){
     
        super(message);
        number=num;
    }
}

```
Здесь для определения ошибки, связанной с вычислением факториала, определен класс FactorialException, который наследуется от Exception и который содержит всю информацию о вычислении. В конструкторе FactorialException в конструктор базового класса Exception передается сообщение об ошибке: super(message). Кроме того, отдельное поле предназначено для хранения числа, факториал которого вычисляется.

Для генерации исключения в методе вычисления факториала выбрасывается исключение с помощью оператора throw: throw new FactorialException("Число не может быть меньше 1", num). Кроме того, так как это исключение не обрабатывается с помощью try..catch, то мы передаем обработку вызывающему методу, используя оператор throws: public static int getFactorial(int num) throws FactorialException

Теперь используем класс в методе main:
```java

public static void main(String[] args){
         
    try{
        int result = Factorial.getFactorial(6);
        System.out.println(result);
    }
    catch(FactorialException ex){
         
        System.out.println(ex.getMessage());
        System.out.println(ex.getNumber());
    }
} 

```
